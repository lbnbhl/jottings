### Java的多态体现在哪

> Java的多态性（polymorphism）是指同一个方法在不同对象上具有不同的行为，也可以理解为一个方法有多种形态。

1. 方法重载（编译时多态）
2. 方法重写（运行时多态）



### Java的继承体现在哪

> Java的继承是一种面向对象的编程特性，它可以让一个类获取另一个类的属性和方法，并且可以在此基础上扩展新的属性和方法。

1. 子类继承父类的属性和方法：Java中的继承允许子类继承父类的属性和方法，子类可以直接访问父类中的属性和方法。
2. 子类可以重写父类的方法：如果子类想要修改父类的某个方法的实现方式，可以通过重写该方法来实现。这样可以保证子类的方法与父类的方法具有相同的名称和参数列表，但是具有不同的实现。
3. 子类可以添加自己的属性和方法：除了继承父类的属性和方法外，子类还可以添加自己的属性和方法，从而实现对父类的扩展。
4. 子类可以使用父类的构造方法：在创建子类对象时，子类会默认调用父类的无参构造方法，但是如果需要使用父类的有参构造方法，可以通过super关键字调用父类的构造方法。
5. 子类可以向上转型为父类类型：Java中的继承允许子类向上转型为父类类型，从而可以更方便地在程序中使用多态性。



### Java的封装体现在哪

> Java中的封装是一种面向对象的编程特性，它可以将数据和方法包装在一个类中，并且限制外部程序对这些数据和方法的访问

1. 数据的隐藏：Java中的封装可以隐藏类的内部数据，通过定义private访问权限的成员变量，可以防止外部程序直接访问这些数据。
2. 方法的封装：除了隐藏数据外，Java中的封装还可以将方法封装在类中，通过定义public访问权限的方法，可以允许外部程序调用这些方法，从而实现对数据的访问和处理。
3. 封装的优点：Java中的封装可以提高代码的安全性和可维护性，通过隐藏数据和方法的实现细节，可以防止外部程序对内部数据的非法操作，同时也可以保护类的实现细节，从而方便后期代码的维护和修改。
4. Getter和Setter方法：Java中的Getter和Setter方法是封装的重要手段，通过定义public访问权限的Getter方法和Setter方法，可以允许外部程序访问和修改类的私有成员变量，同时也可以控制外部程序对这些成员变量的访问方式和范围。



### Java为什么要有接口和抽象类，他们之间有什么相同点和区别

1. 相同点：接口和抽象类都是抽象的，不能被直接实例化，只能作为父类或接口被其他类或接口继承或实现。
2. 区别：
   - 接口(interface)：是一种完全抽象的类型，只包含抽象方法和常量，没有实例变量和构造方法，可以被多重实现，用于描述一组操作，而不关心实现的细节。
   - 抽象类(abstract class)：是一种半抽象的类型，可以包含实例变量和实现了部分或全部抽象方法的具体方法，不能被实例化，只能被继承和子类化，用于描述一组类的共性和行为规范。
   - 接口和抽象类的最大区别在于，接口中只包含抽象方法和常量，而抽象类可以包含具体方法和实例变量。
3. 使用场景：
   - 接口：用于定义一组标准的操作，如集合类中的Iterable接口，用于描述一个可迭代对象的行为规范。
   - 抽象类：用于描述一组类的共性，如动物类中的抽象类Animal，用于描述动物的共性和行为规范。
   - 在设计中，接口一般用于描述一组相关的操作，而抽象类则用于描述一组相关的类的共性和行为规范。



### Java创建对象的方法有哪些

1. 使用new关键字创建对象：使用new关键字可以创建一个新的对象，并返回对象的引用，例如：`Object obj = new Object();`。
2. 使用反射机制创建对象：通过反射机制可以在运行时动态创建对象，通过Class类的newInstance()方法或者Constructor类的newInstance()方法来创建对象。例如：`Class clazz = Class.forName("com.example.User"); Object obj = clazz.newInstance();`。
3. 使用clone()方法创建对象：对于实现了Cloneable接口的对象，可以通过调用对象的clone()方法来创建对象的副本。例如：`Object obj2 = obj1.clone();`。
4. 使用反序列化创建对象：通过反序列化可以将对象从二进制流中反序列化出来，从而得到一个新的对象。例如：`ObjectInputStream in = new ObjectInputStream(new FileInputStream("object.ser")); Object obj = in.readObject();`。



### 为什么要有Java包装类型

1. 基本类型有默认值，而我们常常不需要有默认值
2. 允许基本数据类型具有对象特性：通过将基本数据类型封装为对象，可以为其添加一些对象特性，例如在基本数据类型上使用方法，属性等。
3. 可以将基本数据类型传递给方法和函数：因为基本数据类型不是对象，不能直接作为参数传递给方法和函数，但是包装类型可以。
4. 提供了一些有用的方法：包装类型提供了一些有用的方法，例如在数字类型上执行数字操作等。



### 自动拆装箱原理

~~~java
//装箱
Integer i = 10; 等价于 i.valueOf(10);
//拆箱
int n = i; 等价于 i.intValue();
~~~



### 介绍一下Java的泛型



### Java的类型擦除是什么



### 通配符和泛型的比较

Java通配符：通配符指的是`<?>`，它表示任何类型，用于泛型类型的方法参数中，主要用于灵活地操作泛型类型。

举个例子，假设我们有一个打印任意类型的方法`print`，方法参数是一个泛型集合`List<T>`，我们可以使用通配符来实现该方法。示例代码如下：

```Java
public static void print(List<?> list) {
    for (Object o : list) {
        System.out.println(o);
    }
}
```

在上面的代码中，`<?>`表示任何类型，这样我们就可以将不同类型的集合作为参数传递给`print`方法，比如`List<Integer>`、`List<String>`等等。

泛型：泛型可以用于类、接口、方法的定义中，用于指定类型参数，提供更加严格的类型检查和更好的代码可读性。

举个例子，假设我们有一个泛型类`Pair`，该类有两个属性`first`和`second`，用于存储一对值，我们可以使用泛型来实现该类。示例代码如下：

```java
public class Pair<T, U> {
    private T first;
    private U second;
    
    public Pair(T first, U second) {
        this.first = first;
        this.second = second;
    }
    
    public T getFirst() {
        return first;
    }
    
    public U getSecond() {
        return second;
    }
}
```

在上面的代码中，`<T, U>`表示两个类型参数，这样我们就可以创建不同类型的`Pair`对象，比如`Pair<Integer, String>`、`Pair<String, Double>`等等，而且在代码中可以更加明确地指定类型参数的类型，提高代码的可读性。

综上所述，Java通配符和泛型都是用于实现泛型编程的机制，它们各有优劣，可以根据不同的需求选择合适的机制。



### 项目中哪里用到了泛型



### String、StringBuffer、StringBuilder 的区别



### String为什么不可变

1. 保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。
2. String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。



### 常见序列化方式有哪些，各有什么特点

> 序列化协议的选择通常有下列一些常用的指标：
>
> 1. 通用性。是否只能用于java间序列化/反序列化，是否跨语言，跨平台。
> 2. 性能。分为空间开销和时间开销。序列化后的数据一般用于存储或网络传输，其大小是很重要的一个参数；解析的时间也影响了序列化协议的选择，如今的系统都在追求极致的性能。
> 3. 可扩展性。系统升级不可避免，某一实体的属性变更，会不会导致反序列化异常，也应该纳入序列化协议的考量范围。
> 4. 易用性。API使用是否复杂，会影响开发效率。

#### JDK自带序列化

- 优点：
  1. 由于序列化了所有信息所以相对而言更可靠
- 缺点：
  1. JDK序列化会把对象类的描述和所有属性的元数据都序列化为字节流，另外**继承的元数据也会序列化**，所以导致序列化的元素较多且字节流很大
  2. 一个实例**能直接从byte[]数组创建**，而不经过构造方法，因此，它存在一定的安全隐患
  3. **不支持跨语言调用**

#### Hessian

- 优点：
  1. 和JDK自带的序列化方式类似，Hessian采用的也是二进制协议，只不过Hessian序列化之后，字节数更小，性能更优
  2. 跨语言

#### Kryo

- 优点：
  1. Kryo 是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。
- 缺点：
  1. 只支持Java语言
  2. 线程不安全，需结合ThreadLocal使用
  3. **Kryo不支持Bean中增删字段**
  4. **不支持包含无参构造器类的反序列化**
  5. Kryo使用注册行为最大的问题在于，其不保证同一个Class每一次注册的号码相同，意味着在不同的机器、同一个机器重启前后都有可能拥有不同的编号，这会导致序列化产生问题

#### Protobuf

- 优点：
  1. 非常高效，序列化后的数据很小，占用的网络带宽较少。
  2. 支持跨语言序列化，因此可以与其他语言的应用程序进行通信。
  3. 支持协议升级，可以在不中断旧版本客户端的情况下添加新字段。
- 缺点：
  1. 序列化和反序列化的速度不如Kryo和Hessian快。
  2. 对于嵌套的复杂对象，定义ProtoBuf结构可能需要更多的时间和精力。

#### ProtoStuff

- 优点：
  1. 序列化和反序列化速度较快。
  2. 支持跨语言序列化，因此可以与其他语言的应用程序进行通信。
  3. 与Protobuf相比，更容易使用和配置。
- 缺点：
  1. 不支持协议升级。
  2. 可能会出现类加载问题。

#### 总结

~~~
综上所述，每个框架都有其优点和缺点。在选择使用哪个框架时，需要考虑到应用程序的具体需求和场景。如果需要高性能，可以选择Kryo或Hessian；如果需要更小的数据大小，可以选择Protobuf；如果需要更易用的框架，则可以选择ProtoStuff。
~~~



### 什么是SPI

SPI 的全称是 Service Provider Interface，它是一种服务发现机制。在 Java 中，SPI 机制是指，提供一种服务接口，一般是接口或抽象类，多个厂商或组织提供了各自的实现，放在对应的 jar 包中，使用时，我们只需要用提供者提供的 jar 包中的实现类即可，无需关心具体实现，从而实现了解耦。

SPI 的具体使用流程如下：

1. 定义接口：定义一组接口或抽象类，描述一组服务接口。
2. 定义实现类：不同的厂商或组织提供实现类。
3. 创建配置文件：在 META-INF/services 目录下创建一个以接口全路径命名的文件，内容为提供者的实现类全路径名。
4. 加载服务：通过 ClassLoader 加载配置文件，读取文件内容，加载实现类。
5. 使用服务：通过接口类型获取实现类实例，调用实例方法。

SPI 的优点在于，实现了面向接口编程，支持拓展。在 JDK 中，很多类库都使用了 SPI 机制，例如 JDBC 数据库驱动、Servlet 容器、日志框架等。同时，SPI 机制也是很多开源框架的核心，例如 Dubbo、Spring 等。



### ArrayList和LinkedList区别

**是否保证线程安全：** `ArrayList` 和 `LinkedList` 都是不同步的，也就是不保证线程安全；

**底层数据结构：** `ArrayList` 底层使用的是 **`Object` 数组**；`LinkedList` 底层使用的是 **双向链表** 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）

**插入和删除是否受元素位置的影响：**

- `ArrayList` 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行`add(E e)`方法的时候， `ArrayList` 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（`add(int index, E element)`）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。
- `LinkedList` 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（`add(E e)`、`addFirst(E e)`、`addLast(E e)`、`removeFirst()` 、 `removeLast()`），时间复杂度为 O(1)，如果是要在指定位置 `i` 插入和删除元素的话（`add(int index, E element)`，`remove(Object o)`）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入。

**是否支持快速随机访问：** `LinkedList` 不支持高效的随机元素访问，而 `ArrayList`（实现了RandomAccess接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于`get(int index)`方法)。

**内存空间占用：** `ArrayList` 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。



### HashMap和HashTable区别

1. 线程安全性
2. 底层数据结构
3. 对Null的支持
4. 扩容方式

### ConcurrentHashMap 和 Hashtable 的区别

1. 底层数据结构
2. 实现线程安全的方式



### JDK1.7和1.8的ConcurrentHashMap的实现有什么不同

- **线程安全实现方式** ：JDK 1.7 采用 `Segment` 分段锁来保证安全， `Segment` 是继承自 `ReentrantLock`。JDK1.8 放弃了 `Segment` 分段锁的设计，采用 `Node + CAS + synchronized` 保证线程安全，锁粒度更细，`synchronized` 只锁定当前链表或红黑二叉树的首节点。
- **Hash 碰撞解决方法** : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。
- **并发度** ：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。



### ArrayList扩容机制



### HashMap扩容机制



### HashTable扩容机制



### 进程和线程

1. 进程是资源分配最小单位
2. 线程是程序调度的最小单位



### 线程的生命周期和状态

- 操作系统层面

  <img src="\image\Snipaste_2023-04-18_08-50-53.png" alt="Snipaste_2023-04-18_08-50-53" style="zoom:67%;" />

- Java API层面

  <img src="\image\Snipaste_2023-04-18_08-53-18.png" alt="Snipaste_2023-04-18_08-53-18" style="zoom:65%;" />





### 阻塞和非阻塞，同步和异步

阻塞和非阻塞：

- 阻塞：指当一个进程在执行一个系统调用时，如果该调用无法立即返回结果，那么该进程就会一直等待，直到该调用返回结果为止。
- 非阻塞：指当一个进程在执行一个系统调用时，如果该调用无法立即返回结果，那么该进程会立即返回，继续执行其他任务，直到该调用返回结果。

同步和异步：

- 同步：指一个任务在执行过程中，如果需要等待某个事件的完成，那么该任务会一直等待，直到该事件完成后才会继续执行。
- 异步：指一个任务在执行过程中，如果需要等待某个事件的完成，那么该任务不会一直等待，而是先继续执行其他任务，等到该事件完成后再回来继续执行。

综上所述，阻塞和非阻塞关注的是等待调用结果的方式，而同步和异步关注的是等待调用结果的时机。在实际编程中，我们通常会将异步和非阻塞结合使用，因为异步调用可以避免因等待调用结果而导致的线程阻塞，从而提高程序的并发性能



### Java异步实现方式

1. 回调函数
2. 线程异步
3. Future+callable
4. CompletableFuture
5. Spring的@Async



### 产生死锁的四个必要条件

1. 互斥
2. 请求和保持
3. 不剥夺
4. 循环等待



### sleep、wait、yeild、join、await、park

1. `sleep`：让当前线程进入睡眠状态，暂停执行一段时间，期间不会释放锁。当睡眠时间结束后，线程会重新进入就绪状态等待执行。
2. `wait`：让当前线程进入等待状态，直到其他线程调用该对象的 `notify` 或 `notifyAll` 方法来唤醒该线程。在等待期间，线程会释放对象锁，以便其他线程能够访问该对象。调用 `wait` 方法必须先获得对象的锁，否则会抛出 `IllegalMonitorStateException` 异常。
3. `yield`：暂停当前正在执行的线程，让系统去执行其他的线程。如果其他线程的优先级与当前线程相同，那么系统会随机选择一个线程来执行。注意，调用 `yield` 方法不会释放锁，因此其他线程仍然无法访问当前线程持有的对象。
4. `join`：等待调用该方法的线程结束。例如，当 A 线程调用了 B 线程的 `join` 方法时，A 线程会等待 B 线程执行完毕后再继续执行。
5. `await`：让当前线程等待直到满足特定的条件。与 `wait` 方法类似，调用 `await` 方法的线程会释放对象锁以便其他线程能够访问该对象，等待期间会一直等待条件满足，一旦满足条件，线程会被唤醒并重新尝试获取对象锁。
6. `park`：暂停当前线程，让其进入等待状态，直到其他线程调用该线程的 `unpark` 方法来唤醒该线程。与 `wait` 方法不同的是，调用 `park` 方法不需要先获得对象锁，因此也就没有 `IllegalMonitorStateException` 异常的问题。



### volatile关键字的作用

1. 修饰变量

2. 每次读加读屏障，每次写加写屏障

3. 读屏障的可见性：

   每次读取变量时都到内存中读取

4. 读屏障的有序性：

   读屏障之后的指令不能出现在读屏障之前

5. 写屏障的可见性：

   每次写完刷新到内存

6. 写屏障的有序性：

   写屏障之前的指令不能出现在写屏障之后



### 乐观锁和悲观锁的概念



### Synchronized原理

#### 重量级锁

Moniter对象、Thread对象、Object对象

<img src="image\Snipaste_2023-04-18_19-43-53.png" style="zoom:67%;" />



#### 轻量级锁

Thread对象、Object对象

<img src="image\Snipaste_2023-04-18_19-44-25.png" style="zoom:67%;" />

#### 偏向锁

ThreadID、Object对象

<img src="image\Snipaste_2023-04-18_19-51-53.png" style="zoom:67%;" />





### Synchronized问题

#### 锁膨胀

#### 锁消除

#### 锁自旋

#### 锁粗化



### Java对象头存了什么



### 聊聊AQS

#### AQS是什么

AQS 的全称为 `AbstractQueuedSynchronizer` ，翻译过来的意思就是抽象队列同步器。AQS 就是一个抽象类，主要用来构建锁和同步器。比如我们提到的 `ReentrantLock`，`Semaphore`，其他的诸如 `ReentrantReadWriteLock`，`SynchronousQueue`等等皆是基于 AQS 的。

#### AQS的核心思想是什么

AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 **CLH 队列锁** 实现的，即将暂时获取不到锁的线程加入到队列中。

#### AQS的原理是什么

先介绍下AQS类的`元素`

- 队列

  基于 **CLH 队列锁**

- state

  ~~~java
  用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取
  锁和释放锁
  getState - 获取 state 状态
  setState - 设置 state 状态
  compareAndSetState - cas 机制设置 state 状态
  独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源
  ~~~

- ConditionObject

- 同步器

  ~~~java
  //子类主要通过实现以下方法来构建同步器
  tryAcquire
  tryRelease
  tryAcquireShared
  tryReleaseShared
  isHeldExclusively
  ~~~



#### *CLH 队列锁* 

https://mp.weixin.qq.com/s/jEx-4XhNGOFdCo4Nou5tqg





### 介绍一下Java内存区域

#### 程序计数器

可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令

#### 虚拟机栈

- 概念：执行线程方法时，Java虚拟机都会创建一个栈帧，用来存放当前方法的**局部变量表**、**动态链接**、**操作数栈**、**方法返回地址**。栈帧的生命周期和线程一样，当销毁方法时，栈帧就会弹出。

- 局部变量表

  主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）

- 操作数栈

  存放操作时的中间值或临时变量

- 动态链接

  ~~~java
  在Java虚拟机栈的动态链接中，一个方法的调用并不是像静态链接那样直接调用目标方法的入口地址，而是通过方法在类中的方法表中的索引来进行调用。这样的链接方式被称为动态链接，因为在程序执行期间，方法表可能会被修改，方法的索引也可能会随之改变，但是方法的调用仍然可以被正确地解析。
  
  动态链接的一个优点是，它允许Java程序在运行期间进行类的加载和卸载，这为Java程序的动态性和灵活性提供了便利。此外，动态链接还可以支持Java程序的多态性，因为它允许程序在运行时动态地决定调用哪个方法。
  ~~~

- 方法返回地址

  ~~~java
  Java虚拟机栈的方法返回地址通常是一个指向下一条要执行的指令的地址。在方法调用时，调用者的返回地址被压入虚拟机栈中，当被调用的方法执行完毕后，虚拟机会弹出该返回地址，并跳转到该地址继续执行。在Java程序中，使用return语句可以显式地返回方法的值，同时也会触发虚拟机返回到调用该方法的位置。
  ~~~

#### 本地方法栈

本地方法栈则为虚拟机使用到的 Native 方法服务。

#### 方法区

- 概念：JVM方法区（Method Area）是一种专门用于存储类信息、常量、静态变量、即时编译器编译后的代码等数据的内存区域。

- **为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?**

  1. 整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。
  2. 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。
  3. 元空间的回收不再依赖于Full GC，而是使用了一种新的方式来进行类的卸载，这样可以减少Full GC的频率，从而进一步提高了应用程序的性能。

- 运行时常量池

  Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 **常量池表(Constant Pool Table)**

  常量池表会在类加载后存放到方法区的运行时常量池中。

  运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。

#### 堆

- 概念：Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**Java 堆是垃圾收集器管理的主要区域，因此也被称作 **GC 堆（Garbage Collected Heap）**。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。

- 字符串常量池

  **字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

#### 栈上分配



#### Java对象的创建

1. 类加载检查
2. 分配内存
3. 初始化0值
4. 设置对象头
5. 初始化