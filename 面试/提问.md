### Java的多态体现在哪

> Java的多态性（polymorphism）是指同一个方法在不同对象上具有不同的行为，也可以理解为一个方法有多种形态。

1. 方法重载（编译时多态）
2. 方法重写（运行时多态）



### Java的继承体现在哪

> Java的继承是一种面向对象的编程特性，它可以让一个类获取另一个类的属性和方法，并且可以在此基础上扩展新的属性和方法。

1. 子类继承父类的属性和方法：Java中的继承允许子类继承父类的属性和方法，子类可以直接访问父类中的属性和方法。
2. 子类可以重写父类的方法：如果子类想要修改父类的某个方法的实现方式，可以通过重写该方法来实现。这样可以保证子类的方法与父类的方法具有相同的名称和参数列表，但是具有不同的实现。
3. 子类可以添加自己的属性和方法：除了继承父类的属性和方法外，子类还可以添加自己的属性和方法，从而实现对父类的扩展。
4. 子类可以使用父类的构造方法：在创建子类对象时，子类会默认调用父类的无参构造方法，但是如果需要使用父类的有参构造方法，可以通过super关键字调用父类的构造方法。
5. 子类可以向上转型为父类类型：Java中的继承允许子类向上转型为父类类型，从而可以更方便地在程序中使用多态性。



### Java的封装体现在哪

> Java中的封装是一种面向对象的编程特性，它可以将数据和方法包装在一个类中，并且限制外部程序对这些数据和方法的访问

1. 数据的隐藏：Java中的封装可以隐藏类的内部数据，通过定义private访问权限的成员变量，可以防止外部程序直接访问这些数据。
2. 方法的封装：除了隐藏数据外，Java中的封装还可以将方法封装在类中，通过定义public访问权限的方法，可以允许外部程序调用这些方法，从而实现对数据的访问和处理。
3. 封装的优点：Java中的封装可以提高代码的安全性和可维护性，通过隐藏数据和方法的实现细节，可以防止外部程序对内部数据的非法操作，同时也可以保护类的实现细节，从而方便后期代码的维护和修改。
4. Getter和Setter方法：Java中的Getter和Setter方法是封装的重要手段，通过定义public访问权限的Getter方法和Setter方法，可以允许外部程序访问和修改类的私有成员变量，同时也可以控制外部程序对这些成员变量的访问方式和范围。



### Java为什么要有接口和抽象类，他们之间有什么相同点和区别

1. 相同点：接口和抽象类都是抽象的，不能被直接实例化，只能作为父类或接口被其他类或接口继承或实现。
2. 区别：
   - 接口(interface)：是一种完全抽象的类型，只包含抽象方法和常量，没有实例变量和构造方法，可以被多重实现，用于描述一组操作，而不关心实现的细节。
   - 抽象类(abstract class)：是一种半抽象的类型，可以包含实例变量和实现了部分或全部抽象方法的具体方法，不能被实例化，只能被继承和子类化，用于描述一组类的共性和行为规范。
   - 接口和抽象类的最大区别在于，接口中只包含抽象方法和常量，而抽象类可以包含具体方法和实例变量。
3. 使用场景：
   - 接口：用于定义一组标准的操作，如集合类中的Iterable接口，用于描述一个可迭代对象的行为规范。
   - 抽象类：用于描述一组类的共性，如动物类中的抽象类Animal，用于描述动物的共性和行为规范。
   - 在设计中，接口一般用于描述一组相关的操作，而抽象类则用于描述一组相关的类的共性和行为规范。



### Java创建对象的方法有哪些

1. 使用new关键字创建对象：使用new关键字可以创建一个新的对象，并返回对象的引用，例如：`Object obj = new Object();`。
2. 使用反射机制创建对象：通过反射机制可以在运行时动态创建对象，通过Class类的newInstance()方法或者Constructor类的newInstance()方法来创建对象。例如：`Class clazz = Class.forName("com.example.User"); Object obj = clazz.newInstance();`。
3. 使用clone()方法创建对象：对于实现了Cloneable接口的对象，可以通过调用对象的clone()方法来创建对象的副本。例如：`Object obj2 = obj1.clone();`。
4. 使用反序列化创建对象：通过反序列化可以将对象从二进制流中反序列化出来，从而得到一个新的对象。例如：`ObjectInputStream in = new ObjectInputStream(new FileInputStream("object.ser")); Object obj = in.readObject();`。



### 为什么要有Java包装类型

1. 基本类型有默认值，而我们常常不需要有默认值
2. 允许基本数据类型具有对象特性：通过将基本数据类型封装为对象，可以为其添加一些对象特性，例如在基本数据类型上使用方法，属性等。
3. 可以将基本数据类型传递给方法和函数：因为基本数据类型不是对象，不能直接作为参数传递给方法和函数，但是包装类型可以。
4. 提供了一些有用的方法：包装类型提供了一些有用的方法，例如在数字类型上执行数字操作等。



### 自动拆装箱原理

~~~java
//装箱
Integer i = 10; 等价于 i.valueOf(10);
//拆箱
int n = i; 等价于 i.intValue();
~~~



### 介绍一下Java的泛型



### Java的类型擦除是什么



### 通配符和泛型的比较

Java通配符：通配符指的是`<?>`，它表示任何类型，用于泛型类型的方法参数中，主要用于灵活地操作泛型类型。

举个例子，假设我们有一个打印任意类型的方法`print`，方法参数是一个泛型集合`List<T>`，我们可以使用通配符来实现该方法。示例代码如下：

```Java
public static void print(List<?> list) {
    for (Object o : list) {
        System.out.println(o);
    }
}
```

在上面的代码中，`<?>`表示任何类型，这样我们就可以将不同类型的集合作为参数传递给`print`方法，比如`List<Integer>`、`List<String>`等等。

泛型：泛型可以用于类、接口、方法的定义中，用于指定类型参数，提供更加严格的类型检查和更好的代码可读性。

举个例子，假设我们有一个泛型类`Pair`，该类有两个属性`first`和`second`，用于存储一对值，我们可以使用泛型来实现该类。示例代码如下：

```java
public class Pair<T, U> {
    private T first;
    private U second;
    
    public Pair(T first, U second) {
        this.first = first;
        this.second = second;
    }
    
    public T getFirst() {
        return first;
    }
    
    public U getSecond() {
        return second;
    }
}
```

在上面的代码中，`<T, U>`表示两个类型参数，这样我们就可以创建不同类型的`Pair`对象，比如`Pair<Integer, String>`、`Pair<String, Double>`等等，而且在代码中可以更加明确地指定类型参数的类型，提高代码的可读性。

综上所述，Java通配符和泛型都是用于实现泛型编程的机制，它们各有优劣，可以根据不同的需求选择合适的机制。



### 项目中哪里用到了泛型



### String、StringBuffer、StringBuilder 的区别



### String为什么不可变

1. 保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。
2. String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。



### 常见序列化方式有哪些，各有什么特点

> 序列化协议的选择通常有下列一些常用的指标：
>
> 1. 通用性。是否只能用于java间序列化/反序列化，是否跨语言，跨平台。
> 2. 性能。分为空间开销和时间开销。序列化后的数据一般用于存储或网络传输，其大小是很重要的一个参数；解析的时间也影响了序列化协议的选择，如今的系统都在追求极致的性能。
> 3. 可扩展性。系统升级不可避免，某一实体的属性变更，会不会导致反序列化异常，也应该纳入序列化协议的考量范围。
> 4. 易用性。API使用是否复杂，会影响开发效率。

#### JDK自带序列化

- 优点：
  1. 由于序列化了所有信息所以相对而言更可靠
- 缺点：
  1. JDK序列化会把对象类的描述和所有属性的元数据都序列化为字节流，另外**继承的元数据也会序列化**，所以导致序列化的元素较多且字节流很大
  2. 一个实例**能直接从byte[]数组创建**，而不经过构造方法，因此，它存在一定的安全隐患
  3. **不支持跨语言调用**

#### Hessian

- 优点：
  1. 和JDK自带的序列化方式类似，Hessian采用的也是二进制协议，只不过Hessian序列化之后，字节数更小，性能更优
  2. 跨语言

#### Kryo

- 优点：
  1. Kryo 是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。
- 缺点：
  1. 只支持Java语言
  2. 线程不安全，需结合ThreadLocal使用
  3. **Kryo不支持Bean中增删字段**
  4. **不支持包含无参构造器类的反序列化**
  5. Kryo使用注册行为最大的问题在于，其不保证同一个Class每一次注册的号码相同，意味着在不同的机器、同一个机器重启前后都有可能拥有不同的编号，这会导致序列化产生问题

#### Protobuf

- 优点：
  1. 非常高效，序列化后的数据很小，占用的网络带宽较少。
  2. 支持跨语言序列化，因此可以与其他语言的应用程序进行通信。
  3. 支持协议升级，可以在不中断旧版本客户端的情况下添加新字段。
- 缺点：
  1. 序列化和反序列化的速度不如Kryo和Hessian快。
  2. 对于嵌套的复杂对象，定义ProtoBuf结构可能需要更多的时间和精力。

#### ProtoStuff

- 优点：
  1. 序列化和反序列化速度较快。
  2. 支持跨语言序列化，因此可以与其他语言的应用程序进行通信。
  3. 与Protobuf相比，更容易使用和配置。
- 缺点：
  1. 不支持协议升级。
  2. 可能会出现类加载问题。

#### 总结

~~~
综上所述，每个框架都有其优点和缺点。在选择使用哪个框架时，需要考虑到应用程序的具体需求和场景。如果需要高性能，可以选择Kryo或Hessian；如果需要更小的数据大小，可以选择Protobuf；如果需要更易用的框架，则可以选择ProtoStuff。
~~~



### 什么是SPI

SPI 的全称是 Service Provider Interface，它是一种服务发现机制。在 Java 中，SPI 机制是指，提供一种服务接口，一般是接口或抽象类，多个厂商或组织提供了各自的实现，放在对应的 jar 包中，使用时，我们只需要用提供者提供的 jar 包中的实现类即可，无需关心具体实现，从而实现了解耦。

SPI 的具体使用流程如下：

1. 定义接口：定义一组接口或抽象类，描述一组服务接口。
2. 定义实现类：不同的厂商或组织提供实现类。
3. 创建配置文件：在 META-INF/services 目录下创建一个以接口全路径命名的文件，内容为提供者的实现类全路径名。
4. 加载服务：通过 ClassLoader 加载配置文件，读取文件内容，加载实现类。
5. 使用服务：通过接口类型获取实现类实例，调用实例方法。

SPI 的优点在于，实现了面向接口编程，支持拓展。在 JDK 中，很多类库都使用了 SPI 机制，例如 JDBC 数据库驱动、Servlet 容器、日志框架等。同时，SPI 机制也是很多开源框架的核心，例如 Dubbo、Spring 等。



### ArrayList和LinkedList区别

**是否保证线程安全：** `ArrayList` 和 `LinkedList` 都是不同步的，也就是不保证线程安全；

**底层数据结构：** `ArrayList` 底层使用的是 **`Object` 数组**；`LinkedList` 底层使用的是 **双向链表** 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）

**插入和删除是否受元素位置的影响：**

- `ArrayList` 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行`add(E e)`方法的时候， `ArrayList` 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（`add(int index, E element)`）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。
- `LinkedList` 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（`add(E e)`、`addFirst(E e)`、`addLast(E e)`、`removeFirst()` 、 `removeLast()`），时间复杂度为 O(1)，如果是要在指定位置 `i` 插入和删除元素的话（`add(int index, E element)`，`remove(Object o)`）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入。

**是否支持快速随机访问：** `LinkedList` 不支持高效的随机元素访问，而 `ArrayList`（实现了RandomAccess接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于`get(int index)`方法)。

**内存空间占用：** `ArrayList` 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。



### HashMap和HashTable区别

1. 线程安全性
2. 底层数据结构
3. 对Null的支持
4. 扩容方式

### ConcurrentHashMap 和 Hashtable 的区别

1. 底层数据结构
2. 实现线程安全的方式



### JDK1.7和1.8的ConcurrentHashMap的实现有什么不同

- **线程安全实现方式** ：JDK 1.7 采用 `Segment` 分段锁来保证安全， `Segment` 是继承自 `ReentrantLock`。JDK1.8 放弃了 `Segment` 分段锁的设计，采用 `Node + CAS + synchronized` 保证线程安全，锁粒度更细，`synchronized` 只锁定当前链表或红黑二叉树的首节点。
- **Hash 碰撞解决方法** : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。
- **并发度** ：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。



### ArrayList扩容机制

### HashMap扩容机制

### HashTable扩容机制